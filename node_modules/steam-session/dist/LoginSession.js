"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const stdlib_1 = __importDefault(require("@doctormckay/stdlib"));
const http_1 = require("@doctormckay/stdlib/http");
const crypto_1 = require("crypto");
const debug_1 = __importDefault(require("debug"));
const https_1 = __importDefault(require("https"));
const socks_proxy_agent_1 = require("socks-proxy-agent");
const steamid_1 = __importDefault(require("steamid"));
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const AuthenticationClient_1 = __importDefault(require("./AuthenticationClient"));
const helpers_1 = require("./helpers");
const WebApiTransport_1 = __importDefault(require("./transports/WebApiTransport"));
const WebSocketCMTransport_1 = __importDefault(require("./transports/WebSocketCMTransport"));
const EAuthSessionGuardType_1 = __importDefault(require("./enums-steam/EAuthSessionGuardType"));
const EAuthTokenPlatformType_1 = __importDefault(require("./enums-steam/EAuthTokenPlatformType"));
const EResult_1 = __importDefault(require("./enums-steam/EResult"));
const ESessionPersistence_1 = __importDefault(require("./enums-steam/ESessionPersistence"));
const debug = (0, debug_1.default)('steam-session:LoginSession');
/**
 * Using CommonJS:
 * ```js
 * const {LoginSession} = require('steam-session');
 * ```
 *
 * Using ES6 modules:
 * ```js
 * import {LoginSession} from 'steam-session';
 * ```
 *
 * The {@link LoginSession} class is the primary way to interact with steam-session.
 *
 * @see Example: [login-with-password.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/login-with-password.ts)
 * @see Example: [login-with-qr.ts](https://github.com/DoctorMcKay/node-steam-session/blob/master/examples/login-with-qr.ts)
 */
class LoginSession extends tiny_typed_emitter_1.TypedEmitter {
    /**
     * @param {EAuthTokenPlatformType} platformType - A value from {@link EAuthTokenPlatformType}.
     * You should set this to the appropriate platform type for your desired usage.
     * @param {ConstructorOptions} [options]
     * @return
     *
     * Constructs a new `LoginSession` instance. Example usage:
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * ```
     */
    constructor(platformType, options) {
        super();
        options = options || {};
        let agent = new https_1.default.Agent({ keepAlive: true });
        if (options.httpProxy && options.socksProxy) {
            throw new Error('Cannot specify both httpProxy and socksProxy at the same time');
        }
        if (options.httpProxy) {
            agent = stdlib_1.default.HTTP.getProxyAgent(true, options.httpProxy);
        }
        else if (options.socksProxy) {
            agent = new socks_proxy_agent_1.SocksProxyAgent(options.socksProxy);
        }
        this._webClient = new http_1.HttpClient({ httpsAgent: agent });
        this._platformType = platformType;
        let transport = options.transport;
        if (!transport) {
            switch (platformType) {
                case EAuthTokenPlatformType_1.default.SteamClient:
                    transport = new WebSocketCMTransport_1.default(this._webClient, agent);
                    break;
                default:
                    transport = new WebApiTransport_1.default(this._webClient);
            }
        }
        this._handler = new AuthenticationClient_1.default(this._platformType, transport, this._webClient);
        this._handler.on('debug', (...args) => this.emit('debug-handler', ...args));
        this.on('debug', debug);
        this.loginTimeout = 30000;
    }
    /**
     * A `number` specifying the time, in milliseconds, before a login attempt will {@link timeout}. The timer begins
     * after {@link polling} begins.
     *
     * If you attempt to set this property after {@link polling} has already been emitted, an Error will be thrown since
     * setting this property after that point has no effect.
     */
    get loginTimeout() {
        return this._loginTimeout;
    }
    set loginTimeout(value) {
        if (this._pollingStartedTime) {
            throw new Error('Setting loginTimeout after polling has already started is ineffective');
        }
        this._loginTimeout = value;
    }
    /**
     * **Read-only.** A [`SteamID`](https://www.npmjs.com/package/steamid) instance containing the SteamID for the
     * currently-authenticated account. Populated immediately after {@link startWithCredentials}
     * resolves, or immediately after {@link accessToken} or {@link refreshToken} are set (meaning that
     * this is always populated when {@link authenticated} fires).
     */
    get steamID() {
        // There's a few places we could get a steamid from
        if (this._startSessionResponse && this._startSessionResponse.steamId) {
            return new steamid_1.default(this._startSessionResponse.steamId);
        }
        else if (this.accessToken || this.refreshToken) {
            let token = this.accessToken || this.refreshToken;
            let decodedToken = (0, helpers_1.decodeJwt)(token);
            return new steamid_1.default(decodedToken.sub);
        }
        else {
            return null;
        }
    }
    /**
     * **Read-only.** A `string` containing your account name. This is populated just before the {@link authenticated}
     * event is fired.
     */
    get accountName() { return this._accountName; }
    /**
     * A `string` containing your access token. This is populated just before the {@link authenticated} event is fired.
     * You can also assign an access token to this property if you already have one, although at present that wouldn't
     * do anything useful.
     *
     * Setting this property will throw an Error if:
     *
     * - You set it to a token that isn't well-formed, or
     * - You set it to a refresh token rather than an access token, or
     * - You have already called {@link startWithCredentials} and you set it to a token that doesn't belong to the same account, or
     * - You have already set {@link refreshToken} and you set this to a token that doesn't belong to the same account as the refresh token
     *
     * Access tokens can't be used for much. You can use them with a few undocumented WebAPIs like
     * [IFriendsListService/GetFriendsList](https://steamapi.xpaw.me/#IFriendsListService/GetFriendsList) by passing the access
     * token as an access_token query string parameter. For example:
     *
     *     https://api.steampowered.com/IFriendsListService/GetFriendsList/v1/?access_token=eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...
     *
     * As of time of writing (2023-04-24), it appears that you can also use access tokens with regular published API methods,
     * for example:
     *
     *     https://api.steampowered.com/ISteamUserStats/GetNumberOfCurrentPlayers/v1/?appid=440&access_token=eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...
     *
     * node-steamcommunity also has a method you can use to provide it with an access token:
     * [`setMobileAppAccessToken`](https://github.com/DoctorMcKay/node-steamcommunity/wiki/SteamCommunity#setmobileappaccesstokenaccesstoken)
     */
    get accessToken() { return this._accessToken; }
    set accessToken(token) {
        if (!token) {
            this._accessToken = token;
            return;
        }
        let decoded = (0, helpers_1.decodeJwt)(token);
        try {
            new steamid_1.default(decoded.sub);
        }
        catch {
            throw new Error('Not a valid Steam token');
        }
        let aud = decoded.aud || [];
        if (aud.includes('derive')) {
            throw new Error('The provided token is a refresh token, not an access token');
        }
        if (this._startSessionResponse
            && this._startSessionResponse.steamId
            && decoded.sub != this._startSessionResponse.steamId) {
            throw new Error('Token is for a different account. To work with a different account, create a new LoginSession.');
        }
        if (this._refreshToken) {
            let decodedRefreshToken = (0, helpers_1.decodeJwt)(this._refreshToken);
            if (decodedRefreshToken.sub != decoded.sub) {
                throw new Error('This access token belongs to a different account from the set refresh token.');
            }
        }
        // Everything checks out
        this._accessToken = token;
    }
    /**
     * A `string` containing your refresh token. This is populated just before the {@link authenticated} event is fired.
     * You can also assign a refresh token to this property if you already have one.
     *
     * Setting this property will throw an Error if:
     *
     * - You set it to a token that isn't well-formed, or
     * - You set it to an access token rather than a refresh token, or
     * - You have already called {@link startWithCredentials} and you set it to a token that doesn't belong to the same account, or
     * - You have already set {@link accessToken} and you set this to a token that doesn't belong to the same account as the access token
     */
    get refreshToken() { return this._refreshToken; }
    set refreshToken(token) {
        if (!token) {
            this._refreshToken = token;
            return;
        }
        let decoded = (0, helpers_1.decodeJwt)(token);
        try {
            new steamid_1.default(decoded.sub);
        }
        catch {
            throw new Error('Not a valid Steam token');
        }
        let aud = decoded.aud || [];
        if (!aud.includes('derive')) {
            throw new Error('The provided token is an access token, not a refresh token');
        }
        if (this._startSessionResponse
            && this._startSessionResponse.steamId
            && decoded.sub != this._startSessionResponse.steamId) {
            throw new Error('Token is for a different account. To work with a different account, create a new LoginSession.');
        }
        if (this._accessToken) {
            let decodedAccessToken = (0, helpers_1.decodeJwt)(this._accessToken);
            if (decodedAccessToken.sub != decoded.sub) {
                throw new Error('This refresh token belongs to a different account from the set access token.');
            }
        }
        // Everything checks out
        this._refreshToken = token;
    }
    /**
     * **Read-only.** A `string` containing your Steam Guard machine token. This is populated when you pass a `steamGuardMachineToken` to
     * {@link startWithCredentials}, or just before the {@link steamGuardMachineToken} event is emitted.
     */
    get steamGuardMachineToken() { return this._steamGuardMachineToken; }
    get _defaultWebsiteId() {
        switch (this._platformType) {
            case EAuthTokenPlatformType_1.default.SteamClient:
                return 'Client';
            case EAuthTokenPlatformType_1.default.WebBrowser:
                return 'Community';
            case EAuthTokenPlatformType_1.default.MobileApp:
                return 'Mobile';
            default:
                return 'Community';
        }
    }
    _verifyStarted(mustHaveSteamId = false) {
        if (!this._startSessionResponse) {
            throw new Error('Login session has not been started yet');
        }
        if (this._pollingCanceled) {
            throw new Error('Login attempt has been canceled');
        }
        if (mustHaveSteamId && !this.steamID) {
            throw new Error('Cannot use this method with this login scheme');
        }
    }
    /**
     * @param details
     * @return
     *
     * Starts a new login attempt using your account credentials. Returns a Promise.
     *
     * If you're logging in with {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}, you
     * can supply a Buffer containing the SHA-1 hash of your sentry file for
     * {@link StartLoginSessionWithCredentialsDetails.steamGuardMachineToken}.
     *
     * For example:
     *
     *
     * ```js
     * import {createHash} from 'crypto';
     * import {readFileSync} from 'fs';
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let hash = createHash('sha1');
     * hash.update(readFileSync('ssfn1234567890'));
     * let buffer = hash.digest(); // buffer contains a Buffer
     *
     * let session = new LoginSession(EAuthTokenPlatformType.SteamClient);
     * session.startWithCredentials({
     *     accountName: 'johndoe',
     *     password: 'h3ll0wor1d',
     *     steamGuardMachineToken: buffer
     * });
     * ```
     *
     * If you supply a {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} here and you're using email-based
     * Steam Guard, Steam will send you a new Steam Guard email if you're using {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}
     * or {@link EAuthTokenPlatformType.MobileApp}. You would ideally keep your LoginSession active that generated your
     * first email, and pass the code using {@link submitSteamGuardCode} instead of creating a new LoginSession and
     * supplying the code to {@link startWithCredentials}.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. For example:
     *
     * ```
     * Error: InvalidPassword
     *   eresult: 5
     * ```
     *
     * On success, the Promise will be resolved with a {@link StartSessionResponse} object.
     *
     * Here's a list of which guard types might be present in this method's response, and how you should proceed:
     *
     * - {@link EAuthSessionGuardType.EmailCode}: An email was sent to you containing a code
     *   (`detail` contains your email address' domain, e.g. `gmail.com`).
     *   You should get that code and either call {@link submitSteamGuardCode}, or create a new {@link LoginSession}
     *   and supply that code to the {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} property when calling
     *   {@link startWithCredentials}.
     * - {@link EAuthSessionGuardType.DeviceCode}: You need to supply a TOTP code from your mobile authenticator
     *   (or by using [steam-totp](https://www.npmjs.com/package/steam-totp)).
     *   Get that code and either call {@link submitSteamGuardCode}, or create a new {@link LoginSession} and supply that
     *   code to the {@link StartLoginSessionWithCredentialsDetails.steamGuardCode} property when calling {@link startWithCredentials}.
     * - {@link EAuthSessionGuardType.DeviceConfirmation}: You need to approve the confirmation prompt in your Steam
     *   mobile app. If this guard type is present, {@link polling} will start and {@link loginTimeout} will be in effect.
     * - {@link EAuthSessionGuardType.EmailConfirmation}: You need to approve the confirmation email sent to you. If this
     *   guard type is present, {@link polling} will start and {@link loginTimeout} will be in effect.
     *
     * Note that multiple guard types might be available; for example both {@link EAuthSessionGuardType.DeviceCode} and
     * {@link EAuthSessionGuardType.DeviceConfirmation} can be available at the same time.
     *
     * When this method resolves, {@link steamID} will be populated.
     */
    async startWithCredentials(details) {
        if (this._startSessionResponse) {
            throw new Error('A session has already been started on this LoginSession object. Create a new LoginSession to start a new session.');
        }
        this._hadRemoteInteraction = false;
        this._steamGuardCode = details.steamGuardCode;
        if (typeof details.steamGuardMachineToken == 'string') {
            this._steamGuardMachineToken = details.steamGuardMachineToken;
        }
        let encryptionResult = await this._handler.encryptPassword(details.accountName, details.password);
        this._startSessionResponse = await this._handler.startSessionWithCredentials({
            accountName: details.accountName,
            ...encryptionResult,
            persistence: details.persistence || ESessionPersistence_1.default.Persistent,
            platformType: this._platformType,
            // use a manually-specified token with priority over a token saved on this object
            steamGuardMachineToken: details.steamGuardMachineToken || this.steamGuardMachineToken
        });
        this.emit('debug', 'start session response', this._startSessionResponse);
        return await this._processStartSessionResponse();
    }
    /**
     * @return
     *
     * Starts a new QR login attempt. Returns a Promise.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. Realistically, failures should never happen unless Steam is having problems or you're having network issues.
     *
     * On success, the Promise will be resolved with a {@link StartSessionResponse} object.
     *
     * {@link steamID} will not be populated when this method resolves, since at this point we don't know which account
     * we're going to log into. It will be populated after you successfully {@link authenticated | authenticate}.
     *
     * Immediately after this resolves, {@link LoginSession} will start {@link polling} to determine when authentication
     * has succeeded.
     */
    async startWithQR() {
        if (this._startSessionResponse) {
            throw new Error('A session has already been started on this LoginSession object. Create a new LoginSession to start a new session.');
        }
        this._hadRemoteInteraction = false;
        this._startSessionResponse = await this._handler.startSessionWithQR({
            platformType: this._platformType
        });
        this.emit('debug', 'start qr session response', this._startSessionResponse);
        return await this._processStartSessionResponse();
    }
    async _processStartSessionResponse() {
        this._pollingCanceled = false;
        let validActions = [];
        for (let i of this._startSessionResponse.allowedConfirmations) {
            switch (i.type) {
                case EAuthSessionGuardType_1.default.None:
                    this.emit('debug', 'no guard required');
                    // Use setImmediate here so that the promise is resolved before we potentially emit a session
                    setImmediate(() => this._doPoll());
                    return { actionRequired: false };
                case EAuthSessionGuardType_1.default.EmailCode:
                case EAuthSessionGuardType_1.default.DeviceCode:
                    let codeType = i.type == EAuthSessionGuardType_1.default.EmailCode ? 'email' : 'device';
                    this.emit('debug', `${codeType} code required`);
                    let authResult = await (codeType == 'email' ? this._attemptEmailCodeAuth() : this._attemptTotpCodeAuth());
                    if (authResult) {
                        // We successfully authed already, no action needed
                        return { actionRequired: false };
                    }
                    else {
                        // We need a code from the user
                        let action = { type: i.type };
                        if (i.message) {
                            action.detail = i.message;
                        }
                        validActions.push(action);
                        break;
                    }
                case EAuthSessionGuardType_1.default.DeviceConfirmation:
                case EAuthSessionGuardType_1.default.EmailConfirmation:
                    this.emit('debug', 'device or email confirmation guard required');
                    validActions.push({ type: i.type });
                    setImmediate(() => this._doPoll());
                    break;
                case EAuthSessionGuardType_1.default.MachineToken:
                    // Do nothing here since this is handled by _attemptEmailCodeAuth
                    break;
                default:
                    let guardTypeString = i.type.toString();
                    for (let j in EAuthSessionGuardType_1.default) {
                        if (EAuthSessionGuardType_1.default[j] == guardTypeString) {
                            guardTypeString = j;
                            break;
                        }
                    }
                    throw new Error(`Unknown auth session guard type ${guardTypeString}`);
            }
        }
        // If we got here but we have no valid actions, something went wrong
        if (validActions.length == 0) {
            throw new Error('Login requires action, but we can\'t tell what kind of action is required');
        }
        let response = {
            actionRequired: true,
            validActions
        };
        if (this._startSessionResponse.challengeUrl) {
            let startSessionResponse = this._startSessionResponse;
            response.qrChallengeUrl = startSessionResponse.challengeUrl;
        }
        return response;
    }
    /**
     * @return
     *
     * Forces an immediate polling attempt. This will throw an `Error` if you call it before the {@link polling} event is
     * emitted, after {@link authenticated} is emitted, or after you call {@link cancelLoginAttempt}.
     */
    forcePoll() {
        this._verifyStarted();
        if (!this._pollingStartedTime) {
            throw new Error('Polling has not yet started');
        }
        this._doPoll();
    }
    async _doPoll() {
        if (this._pollingCanceled) {
            return;
        }
        // If we called _doPoll outside of an existing timer, cancel the timer
        clearTimeout(this._pollTimer);
        if (!this._pollingStartedTime) {
            this._pollingStartedTime = Date.now();
            this.emit('polling');
        }
        let totalPollingTime = Date.now() - this._pollingStartedTime;
        if (totalPollingTime >= this.loginTimeout) {
            this.emit('timeout');
            this.cancelLoginAttempt();
            return;
        }
        let pollResponse;
        try {
            pollResponse = await this._handler.pollLoginStatus(this._startSessionResponse);
            this.emit('debug', 'poll response', pollResponse);
        }
        catch (ex) {
            // If we got an error, but we've already canceled polling, just do nothing.
            if (!this._pollingCanceled) {
                this.emit('error', ex);
                this.cancelLoginAttempt();
            }
            return;
        }
        this._startSessionResponse.clientId = pollResponse.newClientId || this._startSessionResponse.clientId;
        if (pollResponse.hadRemoteInteraction && !this._hadRemoteInteraction) {
            this._hadRemoteInteraction = true;
            this.emit('remoteInteraction');
        }
        if (pollResponse.newSteamGuardMachineAuth) {
            this._steamGuardMachineToken = pollResponse.newSteamGuardMachineAuth;
            this.emit('steamGuardMachineToken');
        }
        if (pollResponse.accessToken) {
            this._accountName = pollResponse.accountName;
            this.accessToken = pollResponse.accessToken;
            this.refreshToken = pollResponse.refreshToken;
            this.emit('authenticated');
            this.cancelLoginAttempt();
        }
        else if (!this._pollingCanceled) {
            this._pollTimer = setTimeout(() => this._doPoll(), this._startSessionResponse.pollInterval * 1000);
        }
    }
    /**
     * @returns {boolean} - true if code submitted successfully, false if code wasn't valid or no code available
     */
    async _attemptEmailCodeAuth() {
        if (this._steamGuardCode) {
            try {
                await this.submitSteamGuardCode(this._steamGuardCode);
                return true;
            }
            catch (ex) {
                if (ex.eresult != EResult_1.default.InvalidLoginAuthCode) {
                    // this is some kind of important error
                    throw ex;
                }
            }
        }
        // Can we use a machine auth token?
        if (this._platformType == EAuthTokenPlatformType_1.default.WebBrowser
            && this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.MachineToken)) {
            let result = await this._handler.checkMachineAuthOrSendCodeEmail({
                machineAuthToken: this.steamGuardMachineToken,
                ...this._startSessionResponse
            });
            this.emit('debug', `machine auth check response: ${EResult_1.default[result.result]}`);
            if (result.result == EResult_1.default.OK) {
                // Machine auth succeeded
                setImmediate(() => this._doPoll());
                return true;
            }
        }
        // An email was sent
        return false;
    }
    async _attemptTotpCodeAuth() {
        if (this._steamGuardCode) {
            try {
                await this.submitSteamGuardCode(this._steamGuardCode);
                return true; // submitting code succeeded
            }
            catch (ex) {
                if (ex.eresult != EResult_1.default.TwoFactorCodeMismatch) {
                    // this is some kind of important error
                    throw ex;
                }
            }
        }
        // If we got here, then we need the user to supply a code
        return false;
    }
    /**
     * @param authCode - Your Steam Guard code
     * @return
     *
     * If a Steam Guard code is needed, you can supply it using this method. Returns a Promise.
     *
     * On failure, the Promise will be rejected with its message being equal to the string representation of an {@link EResult}
     * value. There will also be an `eresult` property on the Error object equal to the numeric representation of the relevant
     * EResult value. For example:
     *
     * ```
     * Error: TwoFactorCodeMismatch
     *   eresult: 88
     * ```
     *
     * Note that an incorrect email code will fail with EResult value {@link EResult.InvalidLoginAuthCode} (65), and an
     * incorrect TOTP code will fail with EResult value {@link EResult.TwoFactorCodeMismatch} (88).
     *
     * On success, the Promise will be resolved with no value. In this case, you should expect for {@link authenticated}
     * to be emitted shortly.
     */
    async submitSteamGuardCode(authCode) {
        this._verifyStarted(true);
        this.emit('debug', 'submitting steam guard code', authCode);
        let needsEmailCode = this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.EmailCode);
        let needsTotpCode = this._startSessionResponse.allowedConfirmations.some(c => c.type == EAuthSessionGuardType_1.default.DeviceCode);
        if (!needsEmailCode && !needsTotpCode) {
            throw new Error('No Steam Guard code is needed for this login attempt');
        }
        await this._handler.submitSteamGuardCode({
            ...this._startSessionResponse,
            authCode,
            authCodeType: needsEmailCode ? EAuthSessionGuardType_1.default.EmailCode : EAuthSessionGuardType_1.default.DeviceCode
        });
        setImmediate(() => this._doPoll());
    }
    /**
     * @return - True if we were actively polling and it has now been canceled. False if we were not polling.
     *
     * Cancels {@link polling} for an ongoing login attempt. Once canceled, you should no longer interact with this
     * {@link LoginSession} object, and you should create a new one if you want to start a new attempt.
     */
    cancelLoginAttempt() {
        this._pollingCanceled = true;
        this._handler.close();
        if (this._pollTimer) {
            clearTimeout(this._pollTimer);
            return true;
        }
        return false;
    }
    /**
     * @return
     *
     * Once successfully {@link authenticated}, you can call this method to get cookies for use on the Steam websites.
     * You can also manually set {@link refreshToken} and then call this method without going through another login
     * attempt if you already have a valid refresh token. Returns a Promise.
     *
     * On failure, the Promise will be rejected. Depending on the nature of the failure, an {@link EResult} may or may
     * not be available.
     *
     * On success, the Promise will be resolved with an array of strings. Each string contains a cookie, e.g.
     * `'steamLoginSecure=blahblahblahblah'`.
     *
     * Here's an example of how you can get new web cookies when you already have a valid refresh token:
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * session.refreshToken = 'eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...';
     * let cookies = await session.getWebCookies();
     * ```
     */
    async getWebCookies() {
        if (!this.refreshToken) {
            throw new Error('A refresh token is required to get web cookies');
        }
        let body = {
            nonce: this.refreshToken,
            sessionid: (0, crypto_1.randomBytes)(12).toString('hex'),
            redir: 'https://steamcommunity.com/login/home/?goto='
        };
        debug('POST https://login.steampowered.com/jwt/finalizelogin %o', body);
        let finalizeResponse = await this._webClient.request({
            method: 'POST',
            url: 'https://login.steampowered.com/jwt/finalizelogin',
            headers: helpers_1.API_HEADERS,
            multipartForm: http_1.HttpClient.simpleObjectToMultipartForm(body)
        });
        if (finalizeResponse.jsonBody && finalizeResponse.jsonBody.error) {
            throw (0, helpers_1.eresultError)(finalizeResponse.jsonBody.error);
        }
        if (!finalizeResponse.jsonBody || !finalizeResponse.jsonBody.transfer_info) {
            let err = new Error('Malformed login response');
            err.responseBody = finalizeResponse.jsonBody;
            throw err;
        }
        // Now we want to execute all transfers specified in the finalizelogin response. Technically we only need one
        // successful transfer (hence the usage of promsieAny), but we execute them all for robustness in case one fails.
        // As long as one succeeds, we're good.
        let transfers = finalizeResponse.jsonBody.transfer_info.map(({ url, params }) => new Promise(async (resolve, reject) => {
            let body = { steamID: this.steamID.getSteamID64(), ...params };
            debug('POST %s %o', url, body);
            let result;
            try {
                result = await this._webClient.request({
                    method: 'POST',
                    url,
                    multipartForm: http_1.HttpClient.simpleObjectToMultipartForm(body)
                });
            }
            catch (error) {
                return reject(error);
            }
            if (!result.headers || !result.headers['set-cookie'] || result.headers['set-cookie'].length == 0) {
                return reject(new Error('No Set-Cookie header in result'));
            }
            if (!result.headers['set-cookie'].some(c => c.startsWith('steamLoginSecure='))) {
                return reject(new Error('No steamLoginSecure cookie in result'));
            }
            resolve(result.headers['set-cookie'].map(c => c.split(';')[0].trim()));
        }));
        return await promiseAny(transfers);
    }
    /**
     * @return
     *
     * As long as a {@link refreshToken} is set, you can call this method to obtain a new access token.
     * Returns a Promise.
     *
     * On failure, the Promise will be rejected. An {@link EResult} will be available under the `eresult` property of
     * the Error object.
     *
     * On success, the Promise will be resolved with no value. You can then read the access token from the LoginSession's
     * {@link accessToken} property.
     *
     * ```js
     * import {LoginSession, EAuthTokenPlatformType} from 'steam-session';
     *
     * let session = new LoginSession(EAuthTokenPlatformType.WebBrowser);
     * session.refreshToken = 'eyAidHlwIjogIkpXVCIsICJhbGciOiAiRWREU0EiIH0.eyJpc3MiOiJ...';
     * await session.refreshAccessToken();
     *
     * console.log(`New access token: ${session.accessToken}`);
     * ```
     *
     * As of 2023-04-24, this method works for {@link EAuthTokenPlatformType.MobileApp | EAuthTokenPlatformType.MobileApp}
     * and {@link EAuthTokenPlatformType.SteamClient}, but using {@link EAuthTokenPlatformType.WebBrowser} will fail
     * with response {@link EResult.AccessDenied}.
     */
    async refreshAccessToken() {
        if (!this.refreshToken) {
            throw new Error('A refresh token is required to get a new access token');
        }
        this.accessToken = await this._handler.generateAccessTokenForApp(this.refreshToken);
    }
}
exports.default = LoginSession;
////////////////////////////
// DOCS FOR EVENTS FOLLOW //
////////////////////////////
/**
 * This event is emitted once we start polling Steam to periodically check if the login attempt has succeeded or not.
 * Polling starts when any of these conditions are met:
 *
 * - A login session is successfully started with credentials and no guard is required (e.g. Steam Guard is disabled)*
 * - A login session is successfully started with credentials and you supplied a valid code to {@link StartLoginSessionWithCredentialsDetails.steamGuardCode}*
 * - A login session is successfully started with credentials, you're using email Steam Guard, and you supplied a valid {@link StartLoginSessionWithCredentialsDetails.steamGuardMachineToken}*
 * - A login session is successfully started with credentials, then you supplied a valid code to {@link submitSteamGuardCode}*
 * - A login session is successfully started, and {@link EAuthSessionGuardType.DeviceConfirmation} or {@link EAuthSessionGuardType.EmailConfirmation} are among the valid guards
 * 	 - This case covers {@link startWithQR | QR logins}, since a QR login is a device confirmation under the hood
 *
 * \* = in these cases, we expect to only have to poll once before login succeeds.
 *
 * After this event is emitted, if your {@link loginTimeout} elapses and the login attempt has not yet succeeded,
 * {@link timeout} is emitted and the login attempt is abandoned. You would then need to start a new login attempt
 * using a fresh {@link LoginSession} object.
 *
 * @event
 */
LoginSession.polling = 'polling';
/**
 * This event is emitted when the time specified by {@link loginTimeout} elapses after {@link polling} begins, and
 * the login attempt has not yet succeeded. When `timeout` is emitted, {@link cancelLoginAttempt} is called internally.
 *
 * @event
 */
LoginSession.timeout = 'timeout';
/**
 * This event is emitted when Steam reports a "remote interaction" via {@link polling}. This is observed to happen
 * when the approval prompt is viewed in the Steam mobile app for the {@link EAuthSessionGuardType.DeviceConfirmation}
 * guard. For a {@link startWithQR | QR login}, this would be after you scan the code, but before you tap approve or deny.
 *
 * @event
 */
LoginSession.remoteInteraction = 'remoteInteraction';
/**
 * This event is emitted when Steam sends us a new Steam Guard machine token. Machine tokens are only relevant when logging
 * into an account that has email-based Steam Guard enabled. Thus, this will only be emitted after successfully logging into
 * such an account.
 *
 * At this time, this event is only emitted when logging in using {@link EAuthTokenPlatformType.SteamClient | EAuthTokenPlatformType.SteamClient}.
 * It's not presently possible to get a machine token for the {@link EAuthTokenPlatformType.WebBrowser} platform
 * (and {@link EAuthTokenPlatformType.MobileApp} platform doesn't support machine tokens at all).
 *
 * When this event is emitted, the {@link LoginSession#steamGuardMachineToken} property contains your new machine token.
 *
 * @event
 */
LoginSession.steamGuardMachineToken = 'steamGuardMachineToken';
/**
 * This event is emitted when we successfully authenticate with Steam. At this point, {@link accountName},
 * {@link accessToken}, and {@link refreshToken} are populated. If the {@link EAuthTokenPlatformType}
 * passed to the {@link constructor} is appropriate, you can now safely call {@link getWebCookies}.
 *
 * @event
 */
LoginSession.authenticated = 'authenticated';
/**
 * This event is emitted if we encounter an error while {@link polling}. The first argument to the event handler is
 * an Error object. If this happens, the login attempt has failed and will need to be retried.
 *
 * Node.js will crash if this event is emitted and not handled.
 *
 * ```js
 * session.on('error', (err) => {
 *     console.error(`An error occurred: ${err.message}`);
 * });
 * ```
 *
 * @event
 */
LoginSession.error = 'error';
/**
 * @param {Promise[]} promises
 * @returns {Promise}
 */
function promiseAny(promises) {
    // for node <15 compat
    return new Promise((resolve, reject) => {
        let pendingPromises = promises.length;
        let rejections = [];
        promises.forEach((promise) => {
            promise.then((result) => {
                pendingPromises--;
                resolve(result);
            }).catch((err) => {
                pendingPromises--;
                rejections.push(err);
                if (pendingPromises == 0) {
                    reject(rejections[0]);
                }
            });
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9naW5TZXNzaW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0xvZ2luU2Vzc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlFQUF5QztBQUN6QyxtREFBa0U7QUFDbEUsbUNBQW1DO0FBQ25DLGtEQUFnQztBQUNoQyxrREFBMEI7QUFDMUIseURBQWtEO0FBQ2xELHNEQUE4QjtBQUM5QiwyREFBZ0Q7QUFFaEQsa0ZBQTBEO0FBQzFELHVDQUErRDtBQUUvRCxtRkFBMkQ7QUFDM0QsNkZBQXFFO0FBY3JFLGdHQUF3RTtBQUN4RSxrR0FBMEU7QUFDMUUsb0VBQTRDO0FBQzVDLDRGQUFvRTtBQUVwRSxNQUFNLEtBQUssR0FBRyxJQUFBLGVBQVcsRUFBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBbUJ4RDs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxNQUFxQixZQUFhLFNBQVEsaUNBQWdDO0lBb0J6RTs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsWUFBWSxZQUFvQyxFQUFFLE9BQTRCO1FBQzdFLEtBQUssRUFBRSxDQUFDO1FBRVIsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7UUFFeEIsSUFBSSxLQUFLLEdBQWUsSUFBSSxlQUFLLENBQUMsS0FBSyxDQUFDLEVBQUMsU0FBUyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7UUFDM0QsSUFBSSxPQUFPLENBQUMsU0FBUyxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDNUMsTUFBTSxJQUFJLEtBQUssQ0FBQywrREFBK0QsQ0FBQyxDQUFDO1NBQ2pGO1FBRUQsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQ3RCLEtBQUssR0FBRyxnQkFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQWdCLENBQUM7U0FDMUU7YUFBTSxJQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDOUIsS0FBSyxHQUFHLElBQUksbUNBQWUsQ0FB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